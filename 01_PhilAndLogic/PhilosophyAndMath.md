# Philosophy
As someone who's only barely positioned on the autism scale, I like knowing what something is. If you ever heard that philosophy literally means "the love of wisdom", that probably seemed both obvious from the greek roots, "philo-" and "-sophia" and also left you feeling like you just heard nonsense describing what people already think of as nonsense. However, if I really believed that philosophy was nonsense, then I wouldn't start this book with it.

Let's start with going through the inputs, the outputs, and the "black-box", just like any good software developer does. It would be a vast oversimplification to say that the input to philosophy is questions, and the output is answers. In fact, it's so oversimplified that it's very much wrong.

Instead, slightly closer to reality requires that we look at what a philosopher does. A philosopher doesn't just sit around and ask questions and reach for answers. Instead, a great analogy for what philosophers do is that of design.

## Philosophy as Design
Let's start with what happens wehn a customer would bring requirements to you. For instance, say that a customer came to you saying, "I want a webpage that juggles three balls in the air". Your first reaction would be to state a bunch of assumptions and ask a bunch of clarifying questions.

* "I'm assuming we are talking about animation of balls, since a website cannot physically touch anything."
* "Any particular color of balls are you looking to see?"
* "Do you plan to host this site yourself, or do you expect me to host the site for you?"

The first step of philosophy is also the same. If we are working with questions, we want to know what we are working with. We will spend a lot of time defining things so that we are on the same page, and that's why langauge and the meaning of words factors so heavily in philosophy. Anyone developing for a while should also realize that the hardest thing about programming is often "naming" things, and we are starting to demonstrate why this is so.

If the customer clarifies and comes back with "I want three green balls, but one should be colored red". Immediately, flags should go off and you should note that they are now either asking for 4 balls, or they are asking for something that cannot happen.

Therefore, the next step that most philosophers deal with is the management of expectations. It becomes necessary for any philosophy to state what cannot be answered, and furthermore what would be impossible. If the product they are working on is an answer, then the design should automatically declare what it cannot do, and hence what the answer does not pertain to.

Ultimately, we end up doing simple question-and-answer philosophy via:

1. Identifying the question (i.e. gathering the requirements)
1. Disambiguating and clarifying the question (i.e. clarifying the requirements)
1. Deciding the scope that the question can pertain to (i.e. determining the user base)
1. Determining an answer (i.e. the development-phase)
1. Getting feedback (i.e. testing and User Acceptance Testing)
1. Clarifying the scope of the answer (i.e. known bugs, etc.)

## The Refactor Step
However, code is often not written and discarded; rather it is maintained. Likewise, so is philosophy. The next step of philosophy is beyond the question-and-answer phase but more akin to the abstraction phase. You have rules in programming such as D.R.Y. (Don't Repeat Yourself), which often means that you are abstracting the code to find the commonality.

Likewise, philosophy attempts to do the same, but before it can even possibly do that, it must go one step further and develop processes. Consider first that you don't want to break that which has already been developed, and so you want to develop processes that help with that. This is where philosophy shines.

Originally, if it was something reasoned about, it was classified as being part of philosophy. However, since "modern times" (the actual era defined in philosophy), we have classified these into categories like "math", "science", or "language", etc. In essense, this is all one big part of philosophy, but we often use the word "philosophy" in terms of when it is **not** these things. So, when an average person uses the word "philosophy", what do they mean?

It may not first appear this way, but the output of philosophy, especially in modern times is that of processes. The most important contribution to science that philosophy gave was that of "the Scientific Method". The most important contributions to mathematics was that of "Deduction", or "Axiomatic Math", "Math with Proofs", or "Mathematical Logic".

So, we've now redefined the "output" of philosophy to be "processes" and their "results". We've kind of defined a philosopher as someone who is a developer of rigorous processes, and the "inputs" to process-design philosophy are the many common ways that we find ourselves producing processes for.

 


## Design as Philosophy





$$ 
f(x) = x^2+1 
$$